// Copyright 2022 Doldremus. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v5.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

enum BarcodeFormat {
  /// Barcode format unknown to the current SDK.
  ///
  /// Constant Value: -1
  unknown,
  /// Barcode format constant representing the union of all supported formats.
  ///
  /// Constant Value: 0
  all,
  /// Barcode format constant for Code 128.
  ///
  /// Constant Value: 1
  code128,
  /// Barcode format constant for Code 39.
  ///
  /// Constant Value: 2
  code39,
  /// Barcode format constant for Code 93.
  ///
  /// Constant Value: 4
  code93,
  /// Barcode format constant for Codabar.
  ///
  /// Constant Value: 8
  codebar,
  /// Barcode format constant for Data Matrix.
  ///
  /// Constant Value: 16
  dataMatrix,
  /// Barcode format constant for EAN-13.
  ///
  /// Constant Value: 32
  ean13,
  /// Barcode format constant for EAN-8.
  ///
  /// Constant Value: 64
  ean8,
  /// Barcode format constant for ITF (Interleaved Two-of-Five).
  ///
  /// Constant Value: 128
  itf,
  /// Barcode format constant for QR Code.
  ///
  /// Constant Value: 256
  qrCode,
  /// Barcode format constant for UPC-A.
  ///
  /// Constant Value: 512
  upcA,
  /// Barcode format constant for UPC-E.
  ///
  /// Constant Value: 1024
  upcE,
  /// Barcode format constant for PDF-417.
  ///
  /// Constant Value: 2048
  pdf417,
  /// Barcode format constant for AZTEC.
  ///
  /// Constant Value: 4096
  aztec,
}

/// Barcode value type constants
enum BarcodeType {
  /// Barcode value type unknown, which indicates the current version of SDK cannot recognize the structure of the barcode. Developers can inspect the raw value instead.
  ///
  /// Constant Value: 0
  unknown,
  /// Barcode value type constant for contact information.
  ///
  /// Constant Value: 1
  contactInfo,
  /// Barcode value type constant for email message details.
  ///
  /// Constant Value: 2
  email,
  /// Barcode value type constant for ISBNs.
  ///
  /// Constant Value: 3
  isbn,
  /// Barcode value type constant for phone numbers.
  ///
  /// Constant Value: 4
  phone,
  /// Barcode value type constant for product codes.
  ///
  /// Constant Value: 5
  product,
  /// Barcode value type constant for SMS details.
  ///
  /// Constant Value: 6
  sms,
  /// Barcode value type constant for plain text.
  ///
  /// Constant Value: 7
  text,
  /// Barcode value type constant for URLs/bookmarks.
  ///
  /// Constant Value: 8
  url,
  /// Barcode value type constant for WiFi access point details.
  ///
  /// Constant Value: 9
  wifi,
  /// Barcode value type constant for geographic coordinates.
  ///
  /// Constant Value: 10
  geo,
  /// Barcode value type constant for calendar events.
  ///
  /// Constant Value: 11
  calendarEvent,
  /// Barcode value type constant for driver's license data.
  ///
  /// Constant Value: 12
  driverLicense,
}

class RawBarcode {
  RawBarcode({
    this.corners,
    this.boundingBox,
    this.rawBytes,
    this.rawValue,
    this.format,
    this.type,
  });

  List<BarcodeOffset?>? corners;

  BarcodeBoundingBox? boundingBox;

  Uint8List? rawBytes;

  String? rawValue;

  BarcodeFormat? format;

  BarcodeType? type;

  Object encode() {
    return <Object?>[
      corners,
      boundingBox?.encode(),
      rawBytes,
      rawValue,
      format?.index,
      type?.index,
    ];
  }

  static RawBarcode decode(Object result) {
    result as List<Object?>;
    return RawBarcode(
      corners: (result[0] as List<Object?>?)?.cast<BarcodeOffset?>(),
      boundingBox: result[1] != null
          ? BarcodeBoundingBox.decode(result[1]! as List<Object?>)
          : null,
      rawBytes: result[2] as Uint8List?,
      rawValue: result[3] as String?,
      format: result[4] != null
          ? BarcodeFormat.values[result[4]! as int]
          : null,
      type: result[5] != null
          ? BarcodeType.values[result[5]! as int]
          : null,
    );
  }
}

class BarcodeBoundingBox {
  BarcodeBoundingBox({
    required this.left,
    required this.top,
    required this.right,
    required this.bottom,
  });

  double left;

  double top;

  double right;

  double bottom;

  Object encode() {
    return <Object?>[
      left,
      top,
      right,
      bottom,
    ];
  }

  static BarcodeBoundingBox decode(Object result) {
    result as List<Object?>;
    return BarcodeBoundingBox(
      left: result[0]! as double,
      top: result[1]! as double,
      right: result[2]! as double,
      bottom: result[3]! as double,
    );
  }
}

class BarcodeOffset {
  BarcodeOffset({
    required this.x,
    required this.y,
  });

  double x;

  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static BarcodeOffset decode(Object result) {
    result as List<Object?>;
    return BarcodeOffset(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}

class _BarcodeFlutterApiCodec extends StandardMessageCodec {
  const _BarcodeFlutterApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BarcodeBoundingBox) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is BarcodeOffset) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is RawBarcode) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BarcodeBoundingBox.decode(readValue(buffer)!);
      
      case 129:       
        return BarcodeOffset.decode(readValue(buffer)!);
      
      case 130:       
        return RawBarcode.decode(readValue(buffer)!);
      
      default:

        return super.readValueOfType(type, buffer);
      
    }
  }
}

abstract class BarcodeFlutterApi {
  static const MessageCodec<Object?> codec = _BarcodeFlutterApiCodec();

  void barcodes(List<RawBarcode?>? barcodes);

  static void setup(BarcodeFlutterApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.BarcodeFlutterApi.barcodes', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.BarcodeFlutterApi.barcodes was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final List<RawBarcode?>? arg_barcodes = (args[0] as List<Object?>?)?.cast<RawBarcode?>();
          api.barcodes(arg_barcodes);
          return;
        });
      }
    }
  }
}
